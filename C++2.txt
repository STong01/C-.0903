一、类与对象
1、C++中的结构体struct可以看做是一个域；struct是一个简化版的类；

2、结构体里面的函数，属于这个域，但是不占结构体的空间；

3、结构体在C和C++中的不同：

（1）在C++中，用结构体定义变量不需要加struct，而C中不行；

（2）在C++中，可以定义空结构体，大小为1，而C中不行；

（3）在C++中，可以在结构体中声明甚至实现函数，在C中只能放函数指针；

（4）在C++中，成员函数直接可以访问本结构体的成员变量而无需传入，在C中，函数和结构体并无直接关联；

注：（1）成员函数不影响结构体的大小，因为成员函数是放在公共区域的，只是在这个结构体域中而已；

（2）进行结构体内存对齐，是要进行空间换时间，保证跳转的次数减少，效率变高；

4、类

类是一类特殊的结构体，在上述的结构体中加入public：,把struct改成class就成了一个简单的类；

5、访问限定符

public：正常访问；

private：只能在类内部访问；

protected：目前跟private没有区别；

特点：
（1）访问限定符只在编译阶段生效，编译好后，在运行阶段并没有限定；

（2）结构体其实也能使用访问限定符，只是一般不去使用，因为它是用来兼容C结构体的；

（3）结构体中默认是public，而类中默认是private；
6、this指针（C++关键字）

（1）一般成员函数中都含有一个this指针，这个指针指向调用这个成员函数的对象；

（2）成员函数中，this指针中的成员不需要this指针访问，直接访问即可；

（3）this的类型是当前类类型的指针，this是一个常量指针，不能更改指向；

（4）this指针是成员函数栈里的临时变量，随栈的存在而存在；

（5）this指针可以为空，不能调用修改成员变量的成员函数，成员函数在公共区域里；

（6）写在类内部的成员函数默认inline（内联函数）；

7、类的6个默认成员函数
（1）构造函数：只要对象创造，就会自动调用构造函数，不用手动(显示)调用；

a.当你自己写了构造函数后，系统就不会给你提供默认构造函数；

b.构造函数函数名是类名，或者就是跟类名相同的函数就是构造函数，不存在返回值；

c.构造函数可以存在参数，它与其他的构造函数是以函数重载的方式共同存在；

（2）拷贝构造函数：指的是参数为本类其他对象的引用的构造函数，它在给对象初始化成本类其他对象时调用，系统会自动提供一个拷贝构造函数；

（3）析构函数：是当一个栈被销毁前调用的，在C++中，当一个函数栈被销毁前，会调用栈中每一个对象的析构函数；

a.析构函数不存在参数，也不存在返回值；

b.它的名字的类名前加波浪线~；

c.系统会自动提供一个什么都不做的析构函数；

d.浅拷贝：直接复制内存；

e.深拷贝：当成员中有指向堆的指针，就必须重新给改指针分配空间，然后将目标对象指针所指空间的内容拷贝到新分配的空间。（如果不这样做，会导致两个指针指向同一片空间，从而在析构中多次释放）。

一、初始化列表
1、狭义初始化
在定义变量的时候直接进行初始化的这种行为叫做狭义初始化：
int a = 3;

2、广义初始化
第一次给变量赋值就叫做初始化的情况叫广义初始化
int a;
...//跟a无关的代码
a = 3
初始化列表相当于狭义初始化，而构造函数内部相当于广义初始化
所以初始化列表可以解决一些只能用狭义初始化进行初始化的变量，
例如：
const变量
引用
没有无参构造的类的对象
修饰this指针

explicit：阻止单参构造的不规范调用

单参数的构造函数，可以用=直接调用，例如：
假设CT类中有一个单参数的构造函数，参数类型为int或int相关类型，那么，“CT a = 3;” 这种写法就是被允许的，但是这种写法十分别扭，看上去好像直接把3赋给了a，为了避免这种写法，可以在构造函数加explicit，使得这样的写法变得无效。


二、赋值运算符重载
operator=
运算符重载：
将运算符看成函数，把他的几目当成参数，通过参数的类型识别出对应的操作方法，相当于函数重载。
运算符重载有指定的规则，规则根据运算符来制定。

类会自动提供一个赋值运算符的重载(4)，执行的是浅拷贝，跟拷贝构造相同

三、const成员函数

const加在成员函数的末尾，代表这个函数中的this是const修饰的
如果一个对象是const对象，那么它不能调用非const的成员函数

四、取地址运算符重载

类会自动提供两个取地址运算符重载，一个是针对普通对象的(5)，一个是针对const对象的(6)

五、静态成员

静态成员跟类走不跟对象走，类在他在，而一般成员是对象在他才在。所以静态成员可以通过类名直接调用，而普通成员必须通过对象调用。

静态成员也有private，public，protected之分

1、静态成员变量

1、所有对象共享，无论谁改了，所有的一起改
2、存储在全局区，不占用类的空间，所以取sizeof的时候不算在内
3、赋初值只能在类外，赋值时不加static，用“类型 类名::变量名 = n” 直接赋值

2、静态成员函数

只能直接访问静态成员变量，无法访问其他的普通成员，因为他没有this指针

六、友元函数

友元就是让一个外部函数或者外部类能访问我的私有成员；
友元打破了原有的权限制度，所以十分危险，不建议使用；

内部类：
在另一个类内声明的类；
它属于外部类域中的一员，实例化需要使用域操作运算符（::），同时它有权限的限制。（private的类声明不能直接在外面声明对象）；

外部类是内部类的友元，但是内部类不是外部类的友元；

七、内部类

特性：
1、内部类可以定义在外部类的public、protected、private都是可以的。

2、注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。

3、sizeof(外部类)=外部类，和内部类没有任何关系。




















































































































